<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MEDC Invitational — ADMIN PANEL</title>
  <style>
    :root{
      --bg:#070A12; --card:rgba(255,255,255,.04); --line:rgba(255,255,255,.10);
      --text:#EAF0FF; --muted:rgba(234,240,255,.75);
      --shadow:0 18px 60px rgba(0,0,0,.45); --r:18px;
      --blue:rgba(59,130,246,.22); --blueb:rgba(59,130,246,.35);
      --red:rgba(239,68,68,.18); --redb:rgba(239,68,68,.35);
      --green:rgba(34,197,94,.16); --greenb:rgba(34,197,94,.35);
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,Segoe UI,Arial;background:var(--bg);color:var(--text)}
    header{position:sticky;top:0;z-index:10;background:rgba(7,10,18,.86);backdrop-filter:blur(10px);border-bottom:1px solid var(--line)}
    .wrap{max-width:1200px;margin:0 auto;padding:18px}
    .bar{display:flex;align-items:center;justify-content:space-between;gap:12px}
    .brand{display:flex;align-items:center;gap:12px;font-weight:900}
    .pill{display:inline-flex;gap:8px;align-items:center;padding:6px 10px;border-radius:999px;border:1px solid var(--line);background:rgba(255,255,255,.04);font-size:12px;color:var(--muted)}
    .btn{border:1px solid var(--line); background:rgba(255,255,255,.06); color:var(--text); padding:10px 12px; border-radius:999px; cursor:pointer; font-weight:800;}
    .btn.primary{background:var(--blue);border-color:var(--blueb)}
    .btn.good{background:var(--green);border-color:var(--greenb)}
    .btn.danger{background:var(--red);border-color:var(--redb)}
    .card{background:var(--card);border:1px solid var(--line);border-radius:var(--r);box-shadow:var(--shadow);overflow:hidden}
    .cardPad{padding:16px}
    .grid2{display:grid;grid-template-columns:420px 1fr;gap:14px}
    @media(max-width:980px){.grid2{grid-template-columns:1fr}}
    .muted{color:var(--muted)}
    input,select,button{border-radius:12px;border:1px solid var(--line);background:rgba(0,0,0,.22);color:var(--text);padding:10px 12px;outline:none}
    input{width:100%}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .list{display:flex;flex-direction:column;gap:10px}
    .item{padding:12px;border-radius:16px;border:1px solid var(--line);background:rgba(0,0,0,.20)}
    .itemTop{display:flex;justify-content:space-between;gap:12px;align-items:flex-start}
    .hide{display:none !important}
    .bracketGrid{display:grid;grid-template-columns:repeat(4,1fr);gap:10px;align-items:start}
    @media(max-width:1100px){.bracketGrid{grid-template-columns:repeat(2,1fr)}}
    @media(max-width:600px){.bracketGrid{grid-template-columns:1fr}}
    .match{padding:12px;border-radius:16px;border:1px solid var(--line);background:rgba(0,0,0,.22)}
    .slot{display:flex;justify-content:space-between;align-items:center;gap:10px;padding:8px 10px;border-radius:12px;background:rgba(255,255,255,.05);border:1px solid rgba(255,255,255,.06);margin-bottom:8px}
    .scoreBox{display:flex;gap:8px;align-items:center}
    .scoreBox input{width:64px;text-align:center}
    #dbg{position:fixed;right:14px;bottom:14px;z-index:9999;max-width:520px;padding:10px 12px;border-radius:14px;
      background:rgba(0,0,0,.55);border:1px solid rgba(255,255,255,.14);box-shadow:0 18px 60px rgba(0,0,0,.45);
      font-size:12px;color:rgba(234,240,255,.9);white-space:pre-wrap}
    #dbg.hide{display:none}
  </style>
</head>
<body>
<header>
  <div class="wrap bar">
    <div class="brand">
      <div>MEDC ESPORT ADMIN PANEL</div>
      <span class="pill" id="authPill">Locked</span>
      <span class="pill" id="rolePill">Role: —</span>
    </div>
    <div class="row">
      <button class="btn" type="button" onclick="location.href='index.html'">HOME PAGE</button>
      <button id="logoutBtn" class="btn hide" type="button">Logout</button>
    </div>
  </div>
</header>

<div class="wrap">
  <!-- AUTH VIEW -->
  <section id="authView" class="card">
    <div class="cardPad">
      <h2>Login</h2>
      <p class="muted" style="margin:8px 0 14px">
        Users can register and will be <b>PENDING</b> until approved by owner.
      </p>

      <div class="grid2">
        <!-- Login -->
        <div class="item">
          <div class="muted">Email</div>
          <div style="margin-top:8px"><input id="loginEmail" type="email" placeholder="email@example.com" autocomplete="email"></div>
          <div class="muted" style="margin-top:12px">Password</div>
          <div style="margin-top:8px"><input id="loginPass" type="password" placeholder="password" autocomplete="current-password"></div>

          <div class="row" style="margin-top:12px">
            <button id="loginBtn" class="btn primary" type="button">Login</button>
          </div>

          <p class="muted" style="margin:10px 0 0">
            Accounts use <b>Firebase Authentication</b>. After you register, the owner must approve you before you can access admin tools.
          </p>
          <div class="muted" id="loginMsg" style="margin-top:10px"></div>
        </div>

        <!-- Register -->
        <div class="item">
          <h3 style="margin:0">Request Admin Access</h3>
          <p class="muted" style="margin:8px 0 12px">Create an email/password account. Owner must approve you.</p>

          <div class="muted">Email</div>
          <div style="margin-top:8px"><input id="regEmail" type="email" placeholder="email@example.com" autocomplete="email"></div>

          <div class="muted" style="margin-top:12px">New password</div>
          <div style="margin-top:8px"><input id="regPass" type="password" placeholder="create password (min 6)" autocomplete="new-password"></div>

          <div class="row" style="margin-top:12px">
            <button id="registerBtn" class="btn good" type="button">Register (Request)</button>
          </div>

          <div class="muted" id="regMsg" style="margin-top:10px"></div>
        </div>
      </div>
    </div>
  </section>

  <!-- ADMIN VIEW -->
  <section id="adminView" class="hide">
    <div class="grid2">
      <!-- LEFT -->
      <div class="card">
        <div class="cardPad">
          <div class="row" style="justify-content:space-between">
            <h2 style="margin:0">Teams</h2>
            <span class="pill" id="teamCountPill">0 teams</span>
          </div>

          <div class="item" style="margin-top:12px">
            <div class="muted">Add a team</div>
            <div class="row" style="margin-top:8px">
              <input id="teamName" placeholder="Team name...">
              <button id="addTeamBtn" class="btn primary" type="button">Add</button>
            </div>
          </div>

          <div class="item" style="margin-top:10px">
            <div class="muted">All teams</div>
            <div id="teamsList" class="list" style="margin-top:8px"></div>
          </div>

          <div class="item" style="margin-top:10px">
            <b>Roster Manager</b>
            <div class="muted" style="margin-top:6px">Select team → set captain → add/remove players.</div>

            <div style="margin-top:10px">
              <select id="teamSelect"></select>
            </div>

            <div class="muted" style="margin-top:10px">Team Captain IGN</div>
            <div class="row" style="margin-top:8px">
              <input id="captainName" placeholder="Captain IGN">
              <button id="setCaptainBtn" class="btn good" type="button">Set Captain</button>
            </div>

            <div class="muted" style="margin-top:10px">Add Player IGN</div>
            <div class="row" style="margin-top:8px">
              <input id="playerName" placeholder="Player IGN">
              <button id="addPlayerBtn" class="btn primary" type="button">Add Player</button>
            </div>

            <div class="muted" style="margin-top:10px">Players</div>
            <div id="rosterList" class="list" style="margin-top:8px"></div>
          </div>

          <!-- OWNER ONLY -->
          <div id="ownerUsersBox" class="item hide" style="margin-top:10px">
            <b>User Approvals</b>
            <div class="muted" style="margin-top:6px">Approve/disable/delete admin accounts.</div>
            <div id="usersList" class="list" style="margin-top:10px"></div>
          </div>
        </div>
      </div>

      <!-- RIGHT -->
      <div class="card">
        <div class="cardPad">
          <div class="row" style="justify-content:space-between">
            <h2 style="margin:0">Bracket Control</h2>
            <span class="pill" id="bracketMeta">—</span>
          </div>

          <div class="row" style="margin-top:10px">
            <select id="bracketFormat">
              <option value="single">Single Elimination</option>
              <option value="double">Double Elimination</option>
            </select>
            <select id="bracketMax">
              <option value="8">Up to 8 Teams</option>
              <option value="16" selected>Up to 16 Teams</option>
              <option value="32">Up to 32 Teams</option>
            </select>
            <button id="buildBracketBtn" class="btn primary" type="button">Build / Rebuild</button>
            <button id="autoWireBtn" class="btn" type="button">Auto-Wire / Refresh</button>
            <button id="clearScoresBtn" class="btn" type="button">Clear Scores</button>
            <button id="clearBracketBtn" class="btn danger" type="button">Clear Bracket</button>
          </div>

          <p class="muted" style="margin:10px 0 14px">Assign teams to slots, set scores, pick winners. For double-elimination, use <b>Auto-Wire</b> to place losers into the correct Losers Bracket matches.</p> to slots, set scores, pick winners, advance winners.</p>
          <div id="bracketArea" class="bracketGrid"></div>

          <div class="row" style="margin-top:12px">
            <button id="advanceAllBtn" class="btn" type="button">Auto-Wire / Refresh</button>
          </div>
        </div>
      </div>
    </div>
  </section>
</div>

<div id="dbg" class="hide"></div>

<script type="module">
  // ✅ FIXED VERSION
  // - Uses Firebase v10.13.0 CDN (stable on GitHub Pages)
  // - Fixes isOwner() (your old file had Firestore RULES code in JS which breaks the whole script)
  // - Adds debug box (bottom-right) so you always see the real error

  const dbgEl = document.getElementById("dbg");
  const dbg = (msg) => { dbgEl.classList.remove("hide"); dbgEl.textContent = msg; };
  const dbgAppend = (msg) => { dbgEl.classList.remove("hide"); dbgEl.textContent = (dbgEl.textContent?dbgEl.textContent+"\n":"") + msg; };

  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.13.0/firebase-app.js";
  import {
    getAuth, onAuthStateChanged,
    createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut
  } from "https://www.gstatic.com/firebasejs/10.13.0/firebase-auth.js";
  import {
    getFirestore, doc, getDoc, setDoc, updateDoc, deleteDoc,
    collection, getDocs, serverTimestamp, onSnapshot, query, orderBy
  } from "https://www.gstatic.com/firebasejs/10.13.0/firebase-firestore.js";

  const firebaseConfig = {
  "apiKey": "AIzaSyDZAVhuz9SVBHSCPnEvoxwCjaMrZSQOJ6k",
  "authDomain": "medcesport.firebaseapp.com",
  "projectId": "medcesport",
  "storageBucket": "medcesport.firebasestorage.app",
  "messagingSenderId": "7933255333",
  "appId": "1:7933255333:web:cfe776ebb79f607cdd774c",
  "measurementId": "G-07Z2TFM553"
};
  const OWNER_UID = "bXZ3bSYPakQXEJGwtmkJjctD6Os1";

  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db = getFirestore(app);

  const $ = (id) => document.getElementById(id);
  const uid = () => Math.random().toString(36).slice(2,10);
  function escapeHtml(s=""){ return (""+s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }
  function show(el, yes){ el.classList.toggle("hide", !yes); }
  const niceErr = (e) => (e?.code ? e.code + ": " : "") + (e?.message || String(e));

  function isOwner(user) {
    return !!user && user.uid === OWNER_UID;
  }

  // Tournament doc
  const defaultState = { format:"single", teams:[], bracketSize:8, matches:[], rosters:{} };
  let state = structuredClone(defaultState);
  let unsubTournament = null;

  function normalizeRosters(s) {
    if(!s.rosters) s.rosters = {};
    for(const tid in s.rosters) {
      const v = s.rosters[tid];
      if(Array.isArray(v)) s.rosters[tid] = { captain:"", players:v };
      else {
        if(!v.players) v.players = [];
        if(typeof v.captain !== "string") v.captain = "";
      }
    }
  }
  function ensureRoster(teamId) {
    if(!state.rosters) state.rosters = {};
    if(!state.rosters[teamId]) state.rosters[teamId] = { captain:"", players:[] };
    if(Array.isArray(state.rosters[teamId])) state.rosters[teamId] = { captain:"", players: state.rosters[teamId] };
  }

  async function ensureUserProfile(user, emailOverride="") {
    const ref = doc(db,"users",user.uid);
    const snap = await getDoc(ref);
    const email = emailOverride || user.email || "";
    if(!snap.exists()) {
      await setDoc(ref, {
        email,
        status: isOwner(user) ? "approved" : "pending",
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp()
      }, { merge:true });
    } else {
      await updateDoc(ref, { email, updatedAt: serverTimestamp() }).catch(()=>{});
    }
  }

  async function myApprovalStatus(user) {
    if(isOwner(user)) return "approved";
    const snap = await getDoc(doc(db,"users",user.uid));
    return snap.exists() ? (snap.data()?.status || "pending") : "pending";
  }

  function setRole(role) {
    $("authPill").textContent = role === "none" ? "Locked" : "Unlocked";
    $("rolePill").textContent = "Role: " + (role === "owner" ? "Owner" : role === "admin" ? "Admin" : "—");
    show($("logoutBtn"), role !== "none");
    show($("authView"), role === "none");
    show($("adminView"), role !== "none");
    show($("ownerUsersBox"), role === "owner");
  }

  $("logoutBtn").onclick = () => signOut(auth);

  $("registerBtn").onclick = async () => {
    const email = $("regEmail").value.trim();
    const p = $("regPass").value;
    $("regMsg").textContent = "";

    if(!email) return $("regMsg").textContent = "Enter your email.";
    if(!/^\S+@\S+\.\S+$/.test(email)) return $("regMsg").textContent = "Enter a valid email.";
    if(p.length < 6) return $("regMsg").textContent = "Password must be at least 6 characters.";

    try {
      const cred = await createUserWithEmailAndPassword(auth, email, p);
      await ensureUserProfile(cred.user, email);
      $("regEmail").value = "";
      $("regPass").value = "";
      $("regMsg").textContent = "Request sent! Wait for owner approval.";
      alert("Registered! Your account is pending approval.");
      await signOut(auth);
    } catch(e) {
      console.error(e);
      $("regMsg").textContent = niceErr(e);
      dbg("Register error: " + niceErr(e));
    }
  };

  $("loginBtn").onclick = async () => {
    const email = $("loginEmail").value.trim();
    const p = $("loginPass").value;
    $("loginMsg").textContent = "";

    if(!email) return $("loginMsg").textContent = "Enter your email.";
    if(!/^\S+@\S+\.\S+$/.test(email)) return $("loginMsg").textContent = "Enter a valid email.";

    try {
      await signInWithEmailAndPassword(auth, email, p);
    } catch(e) {
      console.error(e);
      $("loginMsg").textContent = niceErr(e);
      dbg("Login error: " + niceErr(e));
    }
  };

  async function hookTournament() {
    if(unsubTournament) { unsubTournament(); unsubTournament = null; }
    unsubTournament = onSnapshot(doc(db,"tournament","state"), async (snap) => {
      if(!snap.exists()) {
        state = structuredClone(defaultState);
        normalizeRosters(state);
        await setDoc(doc(db,"tournament","state"), {...state, updatedAt: serverTimestamp()}, {merge:true});
      } else {
        state = snap.data() || structuredClone(defaultState);
        if(!state.teams) state.teams = [];
        if(!state.matches) state.matches = [];
        if(!state.bracketSize) state.bracketSize = 8;
        if(!state.format) state.format = "single";
        normalizeRosters(state);
      }
      $("bracketFormat").value = String(state.format || "single");
      renderTeams(); renderTeamSelect(); renderBracket();
    }, (e) => dbg("Tournament snapshot error: " + niceErr(e)));
  }

  // Save (debounced)
  let saveTimer = null;
  function saveState() {
    if(saveTimer) clearTimeout(saveTimer);
    saveTimer = setTimeout(async () => {
      try {
        normalizeRosters(state);
        await setDoc(doc(db,"tournament","state"), {...state, updatedAt: serverTimestamp()}, {merge:true});
      } catch(e) {
        console.error(e);
        dbg("Save failed: " + niceErr(e));
        alert("Save failed. Check Firestore Rules.");
      }
    }, 200);
  }

  // Owner users list
  async function renderUsers() {
    const box = $("usersList");
    box.innerHTML = `<div class="muted">Loading users…</div>`;
    try {
      const qs = await getDocs(query(collection(db,"users"), orderBy("createdAt","desc")));
      const users = [];
      qs.forEach(d => users.push({ uid:d.id, ...d.data() }));
      if(users.length === 0) { box.innerHTML = `<div class="muted">No user requests yet.</div>`; return; }
      box.innerHTML = "";
      users.sort((a,b)=> (a.status===b.status?0 : a.status==="pending"?-1:1)).forEach(u => {
        const div = document.createElement("div");
        div.className = "item";
        const statusPill =
          u.status === "approved" ? `<span class="pill" style="border-color:var(--greenb)">APPROVED</span>` :
          u.status === "disabled" ? `<span class="pill" style="border-color:var(--redb)">DISABLED</span>` :
          `<span class="pill">PENDING</span>`;
        div.innerHTML = `
          <div class="itemTop">
            <div>
              <b>${escapeHtml(u.email || u.uid)}</b>
              <div class="muted">Status: ${statusPill}</div>
            </div>
            <div class="row" style="justify-content:flex-end">
              <button class="btn good" type="button" data-act="approve">Approve</button>
              <button class="btn danger" type="button" data-act="disable">Disable</button>
              <button class="btn" type="button" data-act="delete">Delete</button>
            </div>
          </div>`;
        div.querySelector('[data-act="approve"]').onclick = () => updateUser(u.uid,"approved");
        div.querySelector('[data-act="disable"]').onclick = () => updateUser(u.uid,"disabled");
        div.querySelector('[data-act="delete"]').onclick = () => deleteUser(u.uid);
        box.appendChild(div);
      });
    } catch(e) {
      console.error(e);
      box.innerHTML = `<div class="muted">Failed: ${escapeHtml(niceErr(e))}</div>`;
    }
  }

  async function updateUser(userUid, status) {
    try {
      await updateDoc(doc(db,"users",userUid), { status, updatedAt: serverTimestamp() });
      await renderUsers();
    } catch(e) {
      dbg("Update user failed: " + niceErr(e));
      alert("Update user failed. Check Firestore Rules.");
    }
  }

  async function deleteUser(userUid) {
    if(userUid === OWNER_UID) return alert("Can't delete owner.");
    if(!confirm("Delete this user profile?")) return;
    try {
      await deleteDoc(doc(db,"users",userUid));
      await renderUsers();
    } catch(e) {
      dbg("Delete user failed: " + niceErr(e));
      alert("Delete user failed. Check Firestore Rules.");
    }
  }

  // Teams + Rosters (same as your original)
  function renderTeams() {
    $("teamCountPill").textContent = `${state.teams.length} teams`;
    const list = $("teamsList");
    list.innerHTML = "";
    if(state.teams.length === 0) { list.innerHTML = `<div class="muted">No teams yet. Add teams to begin.</div>`; return; }
    state.teams.forEach(t => {
      ensureRoster(t.id);
      const count = (state.rosters[t.id]?.players || []).length;
      const div = document.createElement("div");
      div.className = "item";
      div.innerHTML = `
        <div class="itemTop">
          <div>
            <b>${escapeHtml(t.name)}</b>
            <div class="muted">ID: ${t.id} • ${count} players</div>
          </div>
          <button class="btn danger" type="button">Remove</button>
        </div>`;
      div.querySelector("button").onclick = () => removeTeam(t.id);
      list.appendChild(div);
    });
  }

  function addTeam() {
    const name = $("teamName").value.trim();
    if(name.length < 2) return alert("Team name too short.");
    if(state.teams.some(t => t.name.toLowerCase() === name.toLowerCase())) return alert("Team already exists.");
    const newTeam = { id: uid(), name };
    state.teams.push(newTeam);
    ensureRoster(newTeam.id);
    $("teamName").value = "";
    saveState();
    renderTeams();
    renderTeamSelect(newTeam.id);
    renderBracket();
  }

  function removeTeam(teamId) {
    if(!confirm("Remove this team?")) return;
    state.teams = state.teams.filter(t => t.id !== teamId);
    if(state.rosters && state.rosters[teamId]) delete state.rosters[teamId];
    state.matches.forEach(m => {
      if(m.aTeamId === teamId) m.aTeamId = "";
      if(m.bTeamId === teamId) m.bTeamId = "";
      if(m.winnerTeamId === teamId) m.winnerTeamId = "";
    });
    saveState();
    renderTeams();
    renderTeamSelect();
    renderBracket();
  }

  $("addTeamBtn").onclick = addTeam;

  function renderTeamSelect(preferredId="") {
    const sel = $("teamSelect");
    sel.innerHTML = "";
    if(state.teams.length === 0) {
      sel.innerHTML = `<option value="">No teams</option>`;
      $("captainName").value = "";
      $("playerName").value = "";
      $("rosterList").innerHTML = `<div class="muted">Create a team first.</div>`;
      return;
    }
    state.teams.forEach(t => {
      const opt = document.createElement("option");
      opt.value = t.id; opt.textContent = t.name;
      sel.appendChild(opt);
    });
    const prev = sel.getAttribute("data-prev") || "";
    const prevOk = state.teams.some(t => t.id === prev);
    let pick = "";
    if(preferredId && state.teams.some(t => t.id === preferredId)) pick = preferredId;
    else if(prevOk) pick = prev;
    else pick = state.teams[0].id;
    sel.value = pick;
    sel.setAttribute("data-prev", pick);
    renderRosterList(pick);
  }

  $("teamSelect").onchange = () => {
    const tid = $("teamSelect").value;
    $("teamSelect").setAttribute("data-prev", tid);
    renderRosterList(tid);
  };

  function renderRosterList(teamId) {
    const list = $("rosterList");
    if(!teamId) {
      $("captainName").value = "";
      list.innerHTML = `<div class="muted">Select a team first.</div>`;
      return;
    }
    ensureRoster(teamId);
    const roster = state.rosters[teamId];
    const players = roster.players || [];
    $("captainName").value = roster.captain || "";
    if(players.length === 0) { list.innerHTML = `<div class="muted">No players yet.</div>`; return; }
    list.innerHTML = "";
    players.forEach((p, idx) => {
      const div = document.createElement("div");
      div.className = "item";
      div.innerHTML = `
        <div class="itemTop">
          <div>
            <b>${escapeHtml(p)}</b>
            <div class="muted">${roster.captain && p.toLowerCase() === roster.captain.toLowerCase() ? "Captain" : "Player"}</div>
          </div>
          <button class="btn danger" type="button">Remove</button>
        </div>`;
      div.querySelector("button").onclick = () => {
        players.splice(idx, 1);
        roster.players = players;
        if(roster.captain && roster.captain.toLowerCase() === p.toLowerCase()) {
          roster.captain = "";
          $("captainName").value = "";
        }
        state.rosters[teamId] = roster;
        saveState();
        renderTeams();
        renderRosterList(teamId);
      };
      list.appendChild(div);
    });
  }

  $("setCaptainBtn").onclick = () => {
    const teamId = $("teamSelect").value;
    if(!teamId) return alert("Select a team first.");
    const cap = $("captainName").value.trim();
    if(cap.length < 2) return alert("Captain IGN too short.");
    ensureRoster(teamId);
    const roster = state.rosters[teamId];
    roster.captain = cap;
    if(!roster.players.some(x => x.toLowerCase() === cap.toLowerCase())) roster.players.unshift(cap);
    state.rosters[teamId] = roster;
    saveState();
    renderTeams();
    renderRosterList(teamId);
  };

  $("addPlayerBtn"
  // Bracket helpers (Single + Double elimination)
  function teamNameById(id) {
    const t = state.teams.find(x => x.id === id);
    return t ? t.name : "";
  }

  const pow2 = (n) => (n & (n-1)) === 0;
  function nextPow2(n){
    n = Math.max(2, Number(n)||2);
    if(pow2(n)) return n;
    let p = 1;
    while(p < n) p <<= 1;
    return p;
  }

  function teamOptions(selectedId) {
    const opts = [`<option value="">— Select team —</option>`];
    state.teams.forEach(t => {
      opts.push(`<option value="${t.id}" ${t.id===selectedId?"selected":""}>${escapeHtml(t.name)}</option>`);
    });
    return opts.join("");
  }

  function matchBy(bracket, round, pos){
    return state.matches.find(m => (m.bracket||"S")===bracket && Number(m.round||1)===round && Number(m.pos||1)===pos);
  }

  function setWinner(match, pick){
    const chosen = pick === "A" ? match.aTeamId : match.bTeamId;
    if(!chosen) return alert("Select a team first.");
    match.winnerTeamId = chosen;
  }

  function getLoserTeamId(m){
    if(!m || !m.winnerTeamId) return "";
    if(m.winnerTeamId === m.aTeamId) return m.bTeamId || "";
    if(m.winnerTeamId === m.bTeamId) return m.aTeamId || "";
    return "";
  }

  function clearWinnerIfInvalid(m){
    if(m.winnerTeamId && m.winnerTeamId !== m.aTeamId && m.winnerTeamId !== m.bTeamId) m.winnerTeamId = "";
  }

  function seedSingle(size){
    // Fill Round 1 slots with current teams in order (no random)
    const t = [...state.teams];
    let idx = 0;
    const r1 = state.matches.filter(m => (m.bracket||"S")==="S" && m.round===1).sort((a,b)=>a.pos-b.pos);
    r1.forEach(m=>{
      m.aTeamId = t[idx]?.id || ""; idx++;
      m.bTeamId = t[idx]?.id || ""; idx++;
      m.scoreA=""; m.scoreB=""; m.winnerTeamId="";
    });
  }

  function buildSingleElimFromTeams(){
    const count = state.teams.length;
    if(count < 2) return alert("Need at least 2 teams.");
    const max = Number($("bracketMax").value || 16);
    const size = nextPow2(count);
    if(size > max){
      alert(`You have ${count} teams. Increase Max Size (current ${max}) to build a proper bracket.`);
      return;
    }
    state.format = "single";
    state.bracketSize = size;

    const rounds = Math.log2(size);
    const matches = [];
    let matchCount = size / 2;
    for(let r=1; r<=rounds; r++) {
      for(let p=1; p<=matchCount; p++) {
        matches.push({ id:`R${r}M${p}`, bracket:"S", round:r, pos:p, aTeamId:"", bTeamId:"", scoreA:"", scoreB:"", winnerTeamId:"" });
      }
      matchCount = matchCount / 2;
    }
    state.matches = matches;
    seedSingle(size);
    saveState();
    renderBracket();
  }

  function seedWinnersRound1(){
    const t = [...state.teams];
    let idx = 0;
    const w1 = state.matches.filter(m => m.bracket==="W" && m.round===1).sort((a,b)=>a.pos-b.pos);
    w1.forEach(m=>{
      m.aTeamId = t[idx]?.id || ""; idx++;
      m.bTeamId = t[idx]?.id || ""; idx++;
      m.scoreA=""; m.scoreB=""; m.winnerTeamId="";
    });
  }

  function buildDoubleElimFromTeams(){
    const count = state.teams.length;
    if(count < 2) return alert("Need at least 2 teams.");
    const max = Number($("bracketMax").value || 16);
    const size = nextPow2(count);
    if(size > max){
      alert(`You have ${count} teams. Increase Max Size (current ${max}) to build a proper bracket.`);
      return;
    }

    state.format = "double";
    state.bracketSize = size;

    const n = Math.log2(size);                 // winners rounds
    const losersRounds = 2*n - 2;              // L1..L(2n-2)

    const matches = [];

    // Winners bracket
    let matchCount = size/2;
    for(let r=1; r<=n; r++){
      for(let p=1; p<=matchCount; p++){
        matches.push({ id:`W-R${r}-M${p}`, bracket:"W", round:r, pos:p, aTeamId:"", bTeamId:"", scoreA:"", scoreB:"", winnerTeamId:"" });
      }
      matchCount/=2;
    }

    // Losers bracket (counts repeat twice: size/4,size/4,size/8,size/8,...,1,1)
    for(let lr=1; lr<=losersRounds; lr++){
      const group = Math.floor((lr+1)/2) + 1; // 2..n
      const countMatches = size / (2 ** group);
      for(let p=1; p<=countMatches; p++){
        matches.push({ id:`L-R${lr}-M${p}`, bracket:"L", round:lr, pos:p, aTeamId:"", bTeamId:"", scoreA:"", scoreB:"", winnerTeamId:"" });
      }
    }

    // Grand Final
    matches.push({ id:`GF`, bracket:"GF", round:1, pos:1, aTeamId:"", bTeamId:"", scoreA:"", scoreB:"", winnerTeamId:"" });

    state.matches = matches;
    seedWinnersRound1();
    autoWireDoubleElim(); // fills L + GF slots based on current winners/losers
    saveState();
    renderBracket();
  }

  function autoWireDoubleElim(){
    // Places teams into the correct downstream matches based on current winners/losers.
    const size = Number(state.bracketSize || 8);
    const n = Math.log2(size);
    const losersRounds = 2*n - 2;

    // Clear all non-WR1 slots first? No — only overwrite computed slots, keep WR1 as is.
    // We DO clear slots in W rounds >1, L rounds all, GF, then repopulate.
    state.matches.forEach(m=>{
      if(m.bracket==="W" && m.round===1) return;
      m.aTeamId = ""; m.bTeamId = "";
      m.scoreA = m.scoreA ?? ""; m.scoreB = m.scoreB ?? "";
      clearWinnerIfInvalid(m);
      // keep scores/winner if teams remain? we clear winner if invalid; leave scores
    });

    // Wire Winners bracket winners forward
    for(let r=1; r<n; r++){
      const thisRound = state.matches.filter(m=>m.bracket==="W" && m.round===r).sort((a,b)=>a.pos-b.pos);
      const nextRound = state.matches.filter(m=>m.bracket==="W" && m.round===r+1).sort((a,b)=>a.pos-b.pos);
      thisRound.forEach((m, i)=>{
        const w = m.winnerTeamId || "";
        if(!w) return;
        const target = nextRound[Math.floor(i/2)];
        if(!target) return;
        const slot = (i%2===0) ? "A" : "B";
        if(slot==="A") target.aTeamId = w; else target.bTeamId = w;
        clearWinnerIfInvalid(target);
      });
    }

    // Wire Losers bracket
    // L1 gets losers from WR1 paired: (W1,W2)->L1M1 ; (W3,W4)->L1M2 ; etc
    const wr1 = state.matches.filter(m=>m.bracket==="W" && m.round===1).sort((a,b)=>a.pos-b.pos);
    const l1 = state.matches.filter(m=>m.bracket==="L" && m.round===1).sort((a,b)=>a.pos-b.pos);
    l1.forEach((lm, j)=>{
      const wA = wr1[2*j];
      const wB = wr1[2*j+1];
      lm.aTeamId = getLoserTeamId(wA) || "";
      lm.bTeamId = getLoserTeamId(wB) || "";
      clearWinnerIfInvalid(lm);
    });

    for(let lr=2; lr<=losersRounds; lr++){
      const cur = state.matches.filter(m=>m.bracket==="L" && m.round===lr).sort((a,b)=>a.pos-b.pos);
      const prev = state.matches.filter(m=>m.bracket==="L" && m.round===lr-1).sort((a,b)=>a.pos-b.pos);

      if(lr % 2 === 0){
        // even LR: winner of previous LR match j vs loser of Winners round (wr = lr/2 + 1) match j
        const wr = (lr/2) + 1;
        const wRound = state.matches.filter(m=>m.bracket==="W" && m.round===wr).sort((a,b)=>a.pos-b.pos);

        cur.forEach((lm, j)=>{
          lm.aTeamId = prev[j]?.winnerTeamId || "";
          lm.bTeamId = getLoserTeamId(wRound[j]) || "";
          clearWinnerIfInvalid(lm);
        });
      } else {
        // odd LR (>1): consolidation, pair winners from prev round: (1,2)->1, (3,4)->2, ...
        cur.forEach((lm, j)=>{
          lm.aTeamId = prev[2*j]?.winnerTeamId || "";
          lm.bTeamId = prev[2*j+1]?.winnerTeamId || "";
          clearWinnerIfInvalid(lm);
        });
      }
    }

    // Grand Final: winner of Winners Final vs winner of last Losers round
    const wFinal = state.matches.find(m=>m.bracket==="W" && m.round===n && m.pos===1);
    const lFinal = state.matches.find(m=>m.bracket==="L" && m.round===losersRounds && m.pos===1);
    const gf = state.matches.find(m=>m.bracket==="GF");
    if(gf){
      gf.aTeamId = wFinal?.winnerTeamId || "";
      gf.bTeamId = lFinal?.winnerTeamId || "";
      clearWinnerIfInvalid(gf);
    }
  }

  function clearScores() {
    state.matches.forEach(m => { m.scoreA=""; m.scoreB=""; m.winnerTeamId=""; });
    saveState();
    renderBracket();
  }

  function clearBracket() {
    if(!confirm("Clear bracket slots + scores?")) return;
    state.matches.forEach(m => { m.aTeamId=""; m.bTeamId=""; m.scoreA=""; m.scoreB=""; m.winnerTeamId=""; });
    saveState();
    renderBracket();
  }

  function renderMatchCard(m){
    const div = document.createElement("div");
    div.className = "match";
    div.innerHTML = `
      <div style="display:flex;justify-content:space-between;gap:10px;align-items:center;margin-bottom:10px">
        <b>${escapeHtml(m.id)}</b>
        <span class="pill">${m.winnerTeamId ? "Winner set" : "No winner"}</span>
      </div>
      <div class="slot">
        <select data-mid="${m.id}" data-slot="A">${teamOptions(m.aTeamId)}</select>
        <div class="scoreBox"><input data-mid="${m.id}" data-score="A" inputmode="numeric" placeholder="0" value="${escapeHtml(m.scoreA)}"></div>
      </div>
      <div class="slot">
        <select data-mid="${m.id}" data-slot="B">${teamOptions(m.bTeamId)}</select>
        <div class="scoreBox"><input data-mid="${m.id}" data-score="B" inputmode="numeric" placeholder="0" value="${escapeHtml(m.scoreB)}"></div>
      </div>
      <div class="row">
        <button class="btn" type="button" data-win="${m.id}" data-pick="A">Pick A Winner</button>
        <button class="btn" type="button" data-win="${m.id}" data-pick="B">Pick B Winner</button>
      </div>
      <div class="muted" style="margin-top:8px">Winner: <b>${escapeHtml(teamNameById(m.winnerTeamId) || "—")}</b></div>
    `;
    return div;
  }

  function renderBracket() {
    const fmt = String(state.format || "single");
    const size = Number(state.bracketSize || nextPow2(Math.max(2, state.teams.length)));
    $("bracketMeta").textContent = `${state.teams.length} teams • ${state.matches.length} matches • ${fmt} • size ${size}`;

    const area = $("bracketArea");
    area.innerHTML = "";
    if(!state.matches || state.matches.length === 0) {
      area.innerHTML = `<div class="muted">No bracket yet. Build one.</div>`;
      return;
    }

    if(fmt === "single"){
      const rounds = Math.log2(state.bracketSize);
      for(let r=1; r<=rounds; r++) {
        const col = document.createElement("div");
        col.className = "list";
        col.innerHTML = `<div class="pill"><b>Round ${r}</b></div>`;
        state.matches
          .filter(m=> (m.bracket||"S")==="S" && m.round===r)
          .sort((a,b)=>a.pos-b.pos)
          .forEach(m=> col.appendChild(renderMatchCard(m)));
        area.appendChild(col);
      }
    } else {
      // Double elimination: Winners + Losers + Grand Final
      const winnersBox = document.createElement("div");
      winnersBox.className = "list";
      winnersBox.innerHTML = `<div class="pill"><b>Winners Bracket</b></div>`;
      const wRounds = Math.log2(state.bracketSize);
      for(let r=1; r<=wRounds; r++){
        const col = document.createElement("div");
        col.className = "item";
        col.innerHTML = `<div class="pill"><b>W-Round ${r}</b></div>`;
        state.matches.filter(m=>m.bracket==="W" && m.round===r).sort((a,b)=>a.pos-b.pos)
          .forEach(m=> col.appendChild(renderMatchCard(m)));
        winnersBox.appendChild(col);
      }

      const losersBox = document.createElement("div");
      losersBox.className = "list";
      losersBox.innerHTML = `<div class="pill"><b>Losers Bracket</b></div>`;
      const lRounds = 2*wRounds - 2;
      for(let r=1; r<=lRounds; r++){
        const col = document.createElement("div");
        col.className = "item";
        col.innerHTML = `<div class="pill"><b>L-Round ${r}</b></div>`;
        state.matches.filter(m=>m.bracket==="L" && m.round===r).sort((a,b)=>a.pos-b.pos)
          .forEach(m=> col.appendChild(renderMatchCard(m)));
        losersBox.appendChild(col);
      }

      const gfBox = document.createElement("div");
      gfBox.className = "list";
      gfBox.innerHTML = `<div class="pill"><b>Grand Final</b></div>`;
      const gf = state.matches.find(m=>m.bracket==="GF");
      if(gf) gfBox.appendChild(renderMatchCard(gf));

      // Put them as 3 columns
      const wrapper = document.createElement("div");
      wrapper.className = "bracketGrid";
      wrapper.style.gridTemplateColumns = "repeat(3, 1fr)";
      wrapper.appendChild(winnersBox);
      wrapper.appendChild(losersBox);
      wrapper.appendChild(gfBox);
      area.appendChild(wrapper);
    }

    // Bind inputs
    area.querySelectorAll("select[data-mid]").forEach(sel => {
      sel.onchange = () => {
        const mid = sel.getAttribute("data-mid");
        const slot = sel.getAttribute("data-slot");
        const match = state.matches.find(x => x.id === mid);
        if(!match) return;
        if(slot === "A") match.aTeamId = sel.value;
        if(slot === "B") match.bTeamId = sel.value;
        clearWinnerIfInvalid(match);
        saveState();
        renderBracket();
      };
    });

    area.querySelectorAll("input[data-mid][data-score]").forEach(inp => {
      inp.oninput = () => {
        const mid = inp.getAttribute("data-mid");
        const which = inp.getAttribute("data-score");
        const match = state.matches.find(x => x.id === mid);
        if(!match) return;
        const v = inp.value.trim();
        if(v !== "" && !/^\d+$/.test(v)) return;
        if(which === "A") match.scoreA = v;
        if(which === "B") match.scoreB = v;
        saveState();
      };
    });

    area.querySelectorAll("button[data-win]").forEach(btn => {
      btn.onclick = () => {
        const mid = btn.getAttribute("data-win");
        const pick = btn.getAttribute("data-pick");
        const match = state.matches.find(x => x.id === mid);
        if(!match) return;
        setWinner(match, pick);
        saveState();
        // For double-elim, we can auto-wire after winners are set
        if((state.format||"single")==="double") autoWireDoubleElim();
        saveState();
        renderBracket();
      };
    });
  }
= () => {
        const mid = btn.getAttribute("data-win");
        const pick = btn.getAttribute("data-pick");
        const match = state.matches.find(x => x.id === mid);
        if(!match) return;
        const chosen = pick === "A" ? match.aTeamId : match.bTeamId;
        if(!chosen) return alert("Select a team first.");
        match.winnerTeamId = chosen;
        saveState();
        renderBracket();
      };
    });

    area.querySelectorAll("button[data-adv]").forEach(btn => {
      btn.onclick = () => advanceWinner(btn.getAttribute("data-adv"));
    });
  }

  $("buildBracketBtn").onclick = () => {
    const fmt = $("bracketFormat").value || "single";
    if(fmt === "double") buildDoubleElimFromTeams();
    else buildSingleElimFromTeams();
  };
  $("clearScoresBtn").onclick = clearScores;
  $("clearBracketBtn").onclick = clearBracket;
  $("autoWireBtn").onclick = () => {
    if((state.format||"single")==="double"){
      autoWireDoubleElim();
      saveState();
      renderBracket();
    }else{
      alert("Auto-Wire is only for double elimination.");
    }
  };
  $("advanceAllBtn").onclick = () => {
    if((state.format||"single")==="double"){
      autoWireDoubleElim();
      saveState();
      renderBracket();
    }else{
      alert("Tip: build single-elim again to re-seed based on teams.");
    }
  };

  dbg("Firebase loaded. Waiting for auth…\nOwner UID: " + OWNER_UID);

  onAuthStateChanged(auth, async (user) => {
    if(!user) {
      setRole("none");
      dbg("Not signed in.");
      return;
    }

    try {
      await ensureUserProfile(user);
      const status = await myApprovalStatus(user);

      if(isOwner(user)) {
        setRole("owner");
        dbg("Signed in as OWNER: " + (user.email||""));
        await hookTournament();
        await renderUsers();
        return;
      }

      if(status !== "approved") {
        setRole("none");
        dbg("Signed in as " + (user.email||"") + " but NOT approved (" + status + ").\nOwner must approve in User Approvals.");
        alert("Your account is not approved yet (or disabled).");
        await signOut(auth);
        return;
      }

      setRole("admin");
      dbg("Signed in as ADMIN: " + (user.email||""));
      await hookTournament();
    } catch(e) {
      dbg("Auth check failed: " + niceErr(e));
      console.error(e);
      alert("Auth check failed: " + niceErr(e));
      await signOut(auth);
    }
  });
</script>
</body>
</html>
